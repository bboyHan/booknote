## 文章目录（Table of Contents）

- [三、进制、数据类型与内存分析](#三变量数据类型与内存分析)
  - [1、字节与进制](#1字节与进制)
  - [2、数据类型](#2数据类型)
    - [2.1 内置数据类型](#21-内置数据类型)
    - [2.2 引用数据类型](#22-引用数据类型)
    - [2.3 数据类型与内存的关系](#23-数据类型与内存的关系)
  - [3、内存分析（堆、栈、方法区）](#3内存分析堆栈方法区)
    - [3.1 堆(Heap)](#31-堆Heap)  
    - [3.2 栈(Stack)](#32-栈Stack)  
      
# 三、进制、数据类型与内存分析

先来看一些声明例子：
```java
int a, b, c;             // 声明三个int型整数：a、 b、c
int d = 3, e = 4, f = 5; // 声明三个整数并赋予初值
byte z = 22;             // 声明并初始化 z
String s = "bboyhan";    // 声明并初始化字符串 s
double pi = 3.14159;     // 声明了双精度浮点型变量 pi
char x = 'x';            // 声明变量 x 的值是字符 'x'。
```

## 1、字节与进制

我们都知道，在计算机里边，所有的一切都是以二进制01的形式进行表示。在计算机中，表示数据的最小单位，叫位（bit），也叫比特位。`byte`，叫做字节。

1byte（也可以表示为1B）=8bit，1KB=1024B。字节换算表如下：

|换算公式|
|---|
|1KB（Kilobyte，千字节）=1024B= 10^3 B|
|1MB（Megabyte，兆字节，百万字节，简称“兆”）=1024KB= 10^6 B|
|1GB（Gigabyte，吉字节，十亿字节，又称“千兆”）=1024MB= 10^9 B|
|1TB（Terabyte，万亿字节，太字节）=1024GB= 10^12 B|
|1PB（Petabyte，千万亿字节，拍字节）=1024TB= 10^15 B|
|1EB（Exabyte，百亿亿字节，艾字节）=1024PB= 10^18 B|
|1ZB（Zettabyte，十万亿亿字节，泽字节）= 1024EB= 10^21 B|
|1YB（Yottabyte，一亿亿亿字节，尧字节）= 1024ZB= 10^24 B|
|1BB（Brontobyte，一千亿亿亿字节）= 1024YB= 10^27 B|
|1NB（NonaByte，一百万亿亿亿字节） = 1024BB = 10^30 B|
|1DB（DoggaByte，十亿亿亿亿字节） = 1024 NB = 10^33 B|

由于数据在计算机中的表示，最终以二进制的形式存在，所以有时候使用二进制，可以更直观地解决问题。但你会发现二进制数太长了。比如int   类型占用4个字节，32位。

比如100，用int类型的二进制数表达将是：0000 0000 0000 0000 0110 0100

这样的表现形式从常人的理解来看，不易读懂也不直观。因此，C、C++、以及java中没有提供在代码直接写二进制数的方法。在Java中提供了八进制和十六进制的表现形式。

**1、八进制表示**

```shell
# 表示方法：在进制数前面加一个零（0）。

# 10进制的100(即 1*10^2+0*10^1+0*10^0 = 100)
int a = 100;

# 8进制的100(即 1*8^2+4*8^1+4*8^0 = 100)
int a = 0144;
```  

**2、十六进制表示**

```shell
# 表示方法：在进制数前面加一个0x。

# 10进制的100(即 1*10^2+0*10^1+0*10^0 = 100)
int a = 100;

# 16进制的100(即 6*16^1+4*16^0 = 100)
int a = 0x64;
```  


## 2、数据类型

我们在[上一篇](https://github.com/bboyHan/booknote/blob/master/java/%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%A7%84%E8%8C%83.md)中了解了“变量”的概念，现在就来深入理解一下。变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。

因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。**Java 分为两大数据类型：内置数据类型(也叫基本类型)、引用数据类型**

+ **基本类型：** 简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。

+ **引用数据类型：** Java语言本身不支持C++中的结构（struct）或联合（union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏。

### 2.1 内置数据类型

Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

|类别| 类型 |说明|字节数|取值返回|默认值|
|---|---|---|---|---|---|
| 整数型  |byte|Java中最小的数据类型，在内存中占8位(bit)|1|-128~127|0|
||short|短整型，在内存中占16位|2|-32768~32717|0|
||int|整型，用于存储整数，在内在中占32位|4|-2147483648~2147483647|0|
||long|长整型，在内存中占64位|8|-2^63~2^63-1|0L|
|浮点型|float|单精度浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位）|4|3.4e-45~1.4e38|0.0f|
||double|双精度浮点型，用于存储带有小数点的数字，在内存中占64位|8|4.9e-324~1.8e308|0.0d|
|字符型|char|字符型，用于存储单个字符，占16位，Unicode码，用单引号赋值|2|0~65535|\`\u0000`|
|布尔型|boolean|布尔类型，占1个字节，用于判断真或假|1|仅有两个值，即true、false|false|


**注：** 实际上，JAVA中还存在另外一种基本类型`void`，它也有对应的包装类 `java.lang.Void`，不过我们无法直接对它们进行操作。

### 2.2 引用数据类型

在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。**对象、数组都是引用数据类型。** 所有引用类型的默认值都是null。

> User a = new User("bboyhan")，即a为引用变量，`new User("bboyhan")`为创建的一个对象实例，a变量指向这个对象。


### 2.3 数据类型与内存的关系

Java的数据类型定义之后进行内存分配，有1个前提条件，即确定变量的类型。确定了变量的类型，即确定了数据需分配内存空间的大小，数据在内存的存储方式。

+ 基本数据类型：所有的内置数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面

+ 引用数据类型：引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储。简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的。由此可见，不管何种引用类型的变量，他们引用的都是对象。

## 3、内存分析（堆、栈、方法区）

Java的程序运行，得益于JVM（Java虚拟机）。因此，在谈到Java的内存问题，其实指的是JVM的内存问题。首先，我们先来理解一下Java程序的执行过程：

![java程序执行过程](https://github.com/bboyHan/booknote/blob/master/img/java_run_process.png)

首先，Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

**运行时数据区** 大致可分为：
1. 堆(Heap)
2. 栈(Stack)，也叫Java虚拟机栈
3. 方法区(Method Area)
4. 程序计数器(Program Counter Register)
5. 本地方法栈(Native Method Stack)

### 3.1 堆（Heap）

### 3.2 栈（Stack）

Java虚拟机栈（Java Virtual Machine Stacks），该区域属于线程私有，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

在Java虚拟机规范中，对这个区域规定了两种异常情况：

1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
2. 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。

![java程序执行过程](https://github.com/bboyHan/booknote/blob/master/img/java_stack.png)

|组成|说明|
|---|---|

